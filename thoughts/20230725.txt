I'm working on three main projects at the moment. All personal / hobby / education projects.

Project 1: Writing an 8086 simulator. A very naive simulator. It's pretty much homework from Casey Muratori's course. This is cool a cool homework. We probably had similar homework at the university but I was too busy not paying attention to teachers that couldn't put words into a coherent sentence. The simulator is in Zig. I was extremely slow at first thanks to Zig. Zig after Clojure feels very slow and it is very slow. Zig doesn't have strings API. Zig's compiler wants everything to be precisely defined. After "typeless" Clojure it was very frustrating. I had to google everything. Now, the simulator is pretty much done according to part 1 of the course and I feel very comfortable writing Zig. Even though I haven't used all the goodness that it provides. No comptime, no build system. Everything is arena allocated.

Project 2: I don't want to spoil it cause it's not done yet. But it's an experiment that I was playing with in my head. Something I wanted to have when working on my previous job with Clojure and ClojureScript. Something for ClojureScript but written in Go. Writing Go after writing Zig is easier than after Clojure but still... The languages are similar enough syntax-wide that I keep mixing the two. One requires semicolons the other doesn't. The loops are different. The if-statements are similar but look different, etc. But with Go you can pretend memory doesn't exist (and pay for it in performance) when you need to get a prototype working fast. The compiler is not as nearly as strict as Zig's but I'm getting way more seg faults with Go trying to use a nil reference. In Zig that can happen but usually you have to explicitly say where you want this to potentially happen. So it's easier to narrow down on the place where it happens in the code.

Project 3: Making an iPhone app. I've had an idea for a yet another workout app that's tailored to only one user - me. I have my own way of programming workouts and I want and app that lets me do that without using pen and paper. I also wanted to do a native app. So it's XCode and Swift and SwiftUI. Swift feels similar to Zig in a lot of ways: optionals for example. Since there are no optionals in Clojure getting some experience with them from Zig was very helpful. Swift is... a programming language. At this point in my programming life I really don't care that much. I can complain about any programming language. Even about Clojure. But XCode is... slow. I have a big MacBook Pro. It's not super new, _only_ from 2019. It has 64 gigs of RAM and the CPU is just silly. And still XCode feels sluggish. Also being spoiled by fast hot-reloading in ClojureScript land the hot-reloading in SwiftUI is very slow. It's so slow it's not even hot-reloading. Some of my other projects are faster to recompile and rerun from scratch then waiting for XCode to show the changes in the preview. I have to Google everything. Trying to use SwiftUI (yeah, I know it's slow and buggy) just cause it seems to be the "official" way Apple wants us to write them apps. It's a learning experience. If I work on the app for a day or two non-stop I get used to the "logic" of things and can almost feel fluency. If it wasn't for the sluggish XCode. I have tried to code in Nvim, but having to jump back and forth between XCode and Nvim was a bit tedious. Also sometimes I would edit something in XCode cause I was already there looking at a preview and then going back to Nvim and forgetting to reload the buffer with the updates from the file and having some conflict errors... Was a bit messy. Maybe I should just hide the coding pane (if it's possible) in XCode and only keep the preview pane and edit only in Nvim... I've seen an Emacs plugin that allows one to see the SwiftUI preview right in Emacs. But that's GUI Emacs. And I'm all terminal NeoVim.

Anyway, I've been busy. My wife keeps telling our friends that I'm working more now when I don't have a job. And it feels almost right. I did code to exhaustion in my last months before getting restructured away. But that's a sad story that a lot of developers (and other workers across the world) share: you can work as hard as humanly possible and still be an number that's too big in a spreadsheet.
